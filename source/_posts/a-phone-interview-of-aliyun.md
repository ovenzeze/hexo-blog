---
title: 记第一次阿里电话面试
date: 2017-03-05 15:57:10
tags:
  - 面试
categories: "经验交流"
---
上周四下午六点多钟的时候接到的电话，由于当时刚吃晚饭，状态不是很好，于是推迟了一个小时，大概八点钟的时候电话很准时的打过来了。简单记录一下我的第一次电话面试。
<!--more-->
面试中问到的问题主要是一下几个：
```
如何选择前端这个方向
Vue双向数据绑定的实现
react和vue有哪些不同 说说你对这两个框架的看法
let和const的区别
const类型的数组可以向其再push一个元素吗
平时用了es6的哪些特性，体验如何
浏览器原生支持module吗，如果支持，会带来哪些便利
介绍一下你对webpack的理解，和gulp有什么不同
webpack打包速度慢，你觉得可能的原因是什么，该如何解决
http响应中content-type包含哪些内容
浏览器缓存有哪些，通常缓存有哪几种方式
如何取出一个数组里的图片并按顺序显示出来
平时是怎么学新技术的
Node，Koa用的怎么样
使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的
```
Vue双向数据绑定的实现
> 目前MVVM框架实现数据绑定的常用方式有如下三种：
**1：发布者-订阅者模式（backbone.js）**
般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是
vm.set('property', value).
**2：脏值检查(angular.js)**
angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：
DOM事件，譬如用户输入文本，点击按钮等。( ng-click )
XHR响应事件 ( $http )
浏览器Location变更事件 ( $location )
Timer事件( $timeout , $interval )
执行 $digest() 或 $apply()
**3：数据劫持(vue.js)**
vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
实现mvvm的双向绑定，就必须要实现以下几点：
1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter。这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。
2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。
3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图
Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:
1、在自身实例化时往属性订阅器(dep)里面添加自己
2、自身必须有一个update()方法
3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。

使用过Vue的哪些库
> vue-router(路由) vue-resource（ajax请求） vuex（状态管理）

let和const的区别
> ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效,不允许重复声明变量 如果块级作用域中使用了let声明变量，那么在变量声明语句前，变量都是不可用的，如果同时用var和let声明相同的变量，不会出现覆盖，而会直接报错。TDZ（暂时性死区）,暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

> const一旦声明变量，就必须立即初始化，不能留到以后赋值。const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。

> for循环还有一个特别之处，就是`循环语句部分`是一个父作用域，而`循环体内部`是一个单独的子作用域。

```
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
```
> 输出结果是三个`abc`,这表明函数内部的变量`i`和外部的变量`i`是分离的.

const类型的数组可以向其再push一个元素吗
> 由上面const类型的解析可知，如果是引用类型的值，是可以改变其指向内存处的值的。

平时用了es6的哪些特性，体验如何
> 新的变量声明命令 let和const  字符串模板 箭头函数 解构赋值 设置默认参数 Proxy监听对象 支持创建类

浏览器原生支持module吗，如果支持，会带来哪些便利
> 现在还不支持，因为规范比较混乱，Node环境是支持的。

介绍一下你对webpack的理解，和gulp有什么不同
> gulp是一个前端自动化的基于任务流的工具，更类似于一个Task Runer,配置好插件和触发条件，它可以把以前你手动操作的事情去自动完成。
而webpack则是一种基于预编译的模块化方案（还有基于在线编译的require.js和sea.js），把一切的内容，包括script文件和静态文件都视为模块（module）,通过require anywhere的理念，可以很方便的做各种事，通过各种loader，转换成项目所需的assets,从项目的角度出发，通过配置来定义所有的操作，更省心更强大。
主要有以下几个配置文件：
entry:{} //加载模块的入口点
output:{}//打包文件的路径和名称
module:{}//那些加载器来处理那些文件
resolve:{}//设置模块的一些细节
plugins:[]//系统插件和扩展插件

webpack打包速度慢，你觉得可能的原因是什么，该如何解决
> 分开发环境和生产环境。
开发环境下在打包时加上一个`--watch`参数（增量打包），就会极大的加快打包的速度；
生产环境下，打包慢的原因主要是每次打包都会把一些不会变化的库文件重新打包（而这些库正好是最大的文件），而实际需要打包的文件仅仅是你的业务代码文件，可以通过配置externals来排除这些文件，但是这种方式排除的包，会在使用各种插件的过程中很容易的又被重新依赖而又重新被打包，更好的方式是手动打包这些依赖的第三方库，再配置externals，不过现在webpack新增webpack.DLLPlugin功能，可以通过打包DLL包，引用DLL包，打包业务代码的方式来降低编译时的包的数量。

平时怎么学新技术
> 官方文档、技术博客、技术论坛、慕课网等

`http`响应中`content-type`包含哪些内容
> 即一般视HTTP响应的内容，主要作用是`指定返回内容的类型`，主要包括住`类型/子类型`，还可以包括`parameter参数`，比如Q参数，`content-type`的编码等。
可以的类型是`媒体格式类型`、`以application开头的媒体格式类型`和`上传文件时用的multipart/form-data类型`。
主类型/子类型 一些可选的参数 ，如字符编码等。
媒体格式类型如下：
text/html ： HTML格式
text/plain ：纯文本格式     
text/xml ：  XML格式
image/gif ：gif图片格式   
image/jpeg ：jpg图片格式
image/png：png图片格式
以application开头的媒体格式类型：
application/xhtml+xml ：XHTML格式
application/xml     ： XML数据格式
application/atom+xml  ：Atom XML聚合格式   
application/json    ： JSON数据格式
application/pdf       ：pdf格式
application/msword  ： Word文档格式
application/octet-stream ： 二进制流数据（如常见的文件下载）
application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

设置缓存有哪几种方式
> 浏览器缓存分为强缓存和协商缓存。
强缓存：浏览器在加载资源时，首先根据资源的HTTP Header判断是否命中强缓存，如果命中，则不会发送请求到服务器。
协商缓存：如果强缓存没有命中，服务器一定会发送一个请求到服务器。通过服务端一些其他的一些HTTP Header去判断是否命中协商缓存，如果命中，服务器会将这个请求返回（304）。但不会返回数据，告诉客户端可以从缓存中加载这个资源，若未命中，则返回数据，并更新本地缓存。
设置缓存通常通过`meta标签`和`HTTP头信息`，meta标签主要通过`pragma` `no-cache`控制，`HTTP Header`主要通过`Expires`（强缓存）、`Cache-control`（强缓存）、`Last-Modified/If-Modified-Since`（协商缓存）、`Etag/If-None-Match`（协商缓存）实现。

如何取出一个数组里的图片并按顺序显示出来
> 当时太紧张了，不知道想问什么。就说了使用一个新数组，记录一下取出图片的顺序，再按照顺序显示出来。其实这个问题是想考察资源的加载顺序，如果不做任何处理的话，因为加载图片是异步的操作，所以无法控制这几张图片加载出来的先后顺序。所以需要在取出图片地址的时候记录一下在数组中的下标，再根据下标依次显示图片。


这是我的第一次面试，很紧张，很多问题都没有回答好，所幸面试官态度非常好，也非常nice,很多我不会的问题还给我找台阶下，最后加了微信，说有结果会通知。总之，还有很多不会，也有很多以前学过的知识忘记了，需要好好复习。

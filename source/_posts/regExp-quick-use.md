layout: '[post]'
title: 正则表达式快速入门
date: 2016-10-08 16:58:17
tags:
 - 正则表达式
 - 前端工具
categories: "基础知识"
---
### 正则表达式简单介绍
最近在学习正则表达式，看了不少博客和视频，发现这是一个非常强大而又有趣的工具，整理了一些基本知识。
顾名思义，正则表达式就是用某种模式去匹配特定格式字符串的一个公式。
使用了它，你就可以抛弃之前各种循环、字符串转数组之类的繁琐方法，转而使用正则非常优美、简洁的匹配任意字符串。
下面就让我们开始30分钟正则之旅。
<!-- more -->
### 正则表达式基本符号
+ **元字符**
正则表达式里有很多很有用的元字符了，如`\b,.,*`，还有`\d.`正则表达式里还有更多的元字符，比如`\s`匹配任意的空白符，包括空格，制表符(`Tab`)，换行符，中文全角空格等。`\w`匹配字母或数字或下划线或汉字等。
具体情况请查看相关文档。


下面来看看更多的例子：
`\ba\w*\b`匹配以字母a开头的单词:先是某个单词开始处(`\b`)，然后是字母`a`,然后是任意数量的字母或数字(`\w*`)，最后是单词结束处`(\b)`。
好吧，现在我们说说正则表达式里的单词是什么意思吧：就是不少于一个的连续的`\w`。不错，这与学习英文时要背的成千上万个同名的东西的确关系不大 :)
`\d+`匹配1个或更多连续的数字。这里的`+`是和`*`类似的元字符，不同的是`*`匹配重复任意次(可能是0次)，而`+`则匹配重复1次或更多次。
`\b\w{6}\b`匹配刚好6个字符的单词。
 常用的元字符 
 
|代码|说明|
|:-----:|:----------------------|
|.|匹配除换行符以外的任意字符|
|\w|匹配字母数字或者下换线|
|\s|匹配任意的空白符|
|\d|匹配数字|
|\b|匹配单词的开头或结尾|
|^|匹配字符串的开始|
|$|匹配字符串的结束|

正则表达式引擎通常会提供一个“测试指定的字符串是否匹配一个正则表达式”的方法，如`JavaScript`里的`RegExp.test()`方法。这里的匹配是指是字符串里有没有符合表达式规则的部分。
元字符`^`（和数字6在同一个键位上的符号）和`$`都匹配一个位置，这和`\b`有点类似。`^`匹配你要用来查找的字符串的开头，`$`匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：`^\d{5,12}$`。
这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配只能不多不少重复2次，`{5,12}`则是重复的次数不能少于5次，不能多于12次，否则都不匹配。
因为使用了`^`和`$`，所以输入的整个字符串都要用来和`\d{5,12}`来匹配，也就是说整个输入必须是5到12个数字，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。

* **常用的限定符**

|代码|说明|
|:-----:|:----------------------|
|*|不出现或出现更多次 >=0|
|+|出现一次或更多次 >=1|
|？|不出现或只出现一次= 0 or = 1|
|{n}|重复N次|
|{n,}|重复N次或更多次|
|{n,m}|重复N次到M次|

* **查找未定义的字符**
想要查找数字、字母、空白、基本符号很容易，因为我们已经有了这些字符的基本字符集。但是如果你想查找的没有特定字符集（比如：元音`a`,`e`,`i`,`o`,`u`，或者只有`?``:``,`三个符号的集合），这样我们可以怎么做呢？
其实我们直接把这些特殊字符直接写出来就可以，如`[aeiou]（匹配任意的元音字母）`、`[?:,]（匹配？ ： ，）`。

* **或操作**
`TIP:没有分组限定的情况下或默认使用前后所有长度的字符去匹配（而量词、开头符、结尾符默认只作用紧挨的一个字符）`
`'¦'`，表示“或”操作：
`"hi¦hello"`：表示一个字符串里有`"hi"`或者`"hello"`；
`"(b¦cd)ef"`：表示`"bef"`或`"cdef"`；
`"(a¦b)*c"`：表示一串`"a""b"`混合的字符串后面跟一个`"c"`；

* **反义**
有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，或者更复杂除了大写字母`A``Z`所有字母都行的情况。

|代码/语法|说明|
|:----------:|:-------------|
|\W|    匹配任意不是字母，数字，下划线，汉字的字符|
|\S|    匹配任意不是空白符的字符|
|\D|匹配任意非数字的字符|
|\B|匹配不是单词开头或结束的位置|
|[^x]|匹配除了`x`以外的任意字符|
|[^aeiou]|匹配除了`aeiou`这几个字母以外的任意字符|

### 正则表达式基本用法
* **分组**
`TIP：分组还有限定操作符作用范围的作用`
我们可以很容易重复单个字符(直接在字符后面加上限定符),但如果想要重复多个字符又该怎么办？
你可以用小括号`()`来指定子表达式(也叫做分组)，然后你可以指定这个子表达式的重复次数。
比如，你要表示IP地址：
`(\d{1,3}\.){3}\d{1,3}`是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：`\d{1,3}`匹配1到3位的数字，`(\d{1,3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字`(\d{1,3})`。
但是IP地址其实并没有这么规则，所以我们不得不用更复杂的分组来表示IP地址。
下面的表达式描述一个正确的IP地址：`( (2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3} (2[0-4]\d|25[0-5]|[01]?\d\d?)`。

* **后向引用**
可以用`$`来捕获分组内的内容，`$1`表示从左到右的第一个分组内的内容，`$2`表示第二个，以此类推。
当我们需要使用分组但是不需要使用分组内的内容时，可以在分组中加入`？：`即可，这个分组就不会出现在分组捕获的列表中。

* **前瞻**
当我们匹配到所需的正则内容时，如果我们还希望他的前面出现或者不能出现某些内容，但是又不需要操作它的时候，如果用现有的方法就非常麻烦，需要匹配到所有的内容并用到分组捕获。
而前瞻语法的出现就非常便利的解决了这个问题。
用法：
`(?=str)`[正向匹配]
表示匹配到字符串时候，向后检查是否有str,有的话匹配成功，否则失败；
`(?!str)`[负向匹配]
表示匹配到字符串时候，向后检查是否有str,没有的话匹配成功，否则失败；

> TIPS:
javaScript是从文本前部到后部解析的语言，所以文本的尾部在解析器的角度看是“前";
前瞻就是在正则匹配到规则的时候向前检查是否符合断言，后顾/后瞻方向相反（javaScript不支持后瞻);
符合断言称为正向（肯定）匹配，不符合断言称为负向（否定）匹配；
>

来看几个简单的例子。
```bash
var reg=/[a-z]+(?!coder)/g;
//匹配前面是一次及以上次数的小写字母，同时后面不是coder，全局匹配；
简单来说，就是字母开始，不以coder结束就可以
'abdefcoderdddd'.match(reg);//["abde"]
//为什么返回abde呢？其实很合理，匹配到f的时候，前瞻时发现后面紧跟
着的是coder所以匹配失败，为什么到这里匹配就停止了呢，再看一个例子。
'abdefcoderghijkcodermnopq'.match(reg);//["abde","ghij","mnopq"]
这样大家就明白了吧，匹配到前瞻的内容时，会自动跳过并从后面继续匹配，
直至匹配到下一个前瞻内容。
```

* **对象属性**
> gobal：是否全文搜索，默认值false，用法g;
ignoreCase:是否忽略大小写搜索，默认值false，用法i;
multiline:是否多行搜索，默认值false，用法m;
source:当前正则表达式的文本字符串；
lastIndex:正则表达式匹配到内容的下一个位置，默认是开启的，从0开始；（下一次匹配从这个位置开始，匹配过的部分不再检索，只在全局匹配时生效）
>

* **正则表达式方法**
`text()`方法
用法：`RegExp.prototype.test(str)`
功能：检测字符串中是否有符合正则表达式的内容，匹配成功返回`true`，匹配失败返回`false`；
`exec()`方法
用法：`RegExp.prototype.exec(str)`
功能：使用正则表达式模式对字符串进行匹配，并将匹配结果更新到全局的`RegExp`对象属性上；
如果没有匹配上返回`null`,否则返回一个结果数组；
数组的属性：
`index`：匹配成功文本的第一个字符的位置；
`input`：存放被检索的字符串；

> 数组的内容：
第一个元素是与正则表达式相匹配的文本；
第二个元素是正则表达式相匹配的部分中第一个字表达式的匹配的文本（如果有的话）；
同理，第三个、第四个是与第二个、第三个表达式匹配的文本；
>

* **字符串对象方法**（字符串中与正则相关的方法）
`TIPS:
字符串对象方法不支持正则表达式方法中的index、lastIndex属性；
在使用字符串的相关方法时，就算你使用的不是正则表达式，js会自动尝试将其转换成正则模式；`
用法：
`string.prototype.search(reg)`
功能：检索与正则表达式相匹配的字符串，返回匹配结果的索引值，匹配失败返回`-1`，不支持`gobal`;
用法：
`string.prototype.match(reg)`
功能：检索与正则表达式相匹配的字符串，返回匹配结果数组，匹配失败返回`-1`，支持`gobal`;
用法：
`string.prototype.split(reg)`
功能：使用正则表达式模式分割字符串成数组；
用法：
`string.prototype.replace(reg,str)` 
`string.prototype.replace(str1,str)`
`string.prototype.replace(reg,function)`
功能：使用正则表达式`reg`或`str1`匹配字符串并将内容替换成`str`；
对于第三种用法，最后的参数`function`,是一个回调函数，每次有匹配结果时会执行一次，使用函数的返回值替换匹配到的内容；
`function`至少有三个参数：
参数一：匹配到的字符串；
参数二：正则表达式分组内容；（长度不定）
参数三：匹配项在字符串中的索引；
参数四：原字符串；
* 贪心匹配和惰性匹配
默认情况下,正则表达式会默认匹配尽可能多的字符。举个例子：

```bash
123456789.replace(/\d{2,6}/g,"num");
number89//默认匹配到了123456六位数字
```

默认匹配到了6个数字而不是2个，因为默认的贪婪模式下，正则表达式会尽可能多的匹配字符。
有时候我么需要用到惰性匹配，是正则表达式尽可能少的匹配字符，这时候我们需要用到`？`。
通过在限定符后加`？`可以使正则表达式尽可能少的匹配字符串。
```bash
123456789.replace(/\d{2,6}?/g,"num");
numnumnumnum9//分别匹配到12,34,56,78共四次
```
### 常用的正则表达式模式
`"^\\d+$"`　　//非负整数（正整数 + 0）
`"^[0-9]*[1-9][0-9]*$"`　　//正整数
`"^((-\\d+)|(0+))$"`　　//非正整数（负整数 + 0）
`"^-[0-9]*[1-9][0-9]*$"`　　//负整数
`"^-?\\d+$"`　　　　//整数
`"^\\d+(\\.\\d+)?$"`　　//非负浮点数（正浮点数 + 0）
`"^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$"`　　//正浮点数
`"^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$"`　　//非正浮点数（负浮点数 + 0）
`"^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"`　　//负浮点数
`"^(-?\\d+)(\\.\\d+)?$"`　　//浮点数
`"^[A-Za-z]+$"`　　//由26个英文字母组成的字符串
`"^[A-Z]+$"`　　//由26个英文字母的大写组成的字符串
`"^[a-z]+$"`　　//由26个英文字母的小写组成的字符串
`"^[A-Za-z0-9]+$"`　　//由数字和26个英文字母组成的字符串
`"^\\w+$"`　　//由数字、26个英文字母或者下划线组成的字符串
`"^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$"`　　//email地址
`"^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$"`　//url
